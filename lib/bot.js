// Generated by CoffeeScript 1.3.3
var AUTH, USERID, VDubsId, bot, config, debug, initroom, log, newbot, rand, room, vote_commentary, wait, _ref, _ref1,
  __slice = [].slice;

config = require("../config.json");

config.debug = (_ref = process.env.DEBUG) != null ? _ref : false;

config.log = (_ref1 = process.env.LOG) != null ? _ref1 : false;

VDubsId = config.userids.vdubs;

AUTH = config.auths[process.argv[2]];

USERID = config.userids[process.argv[2]];

room = null;

initroom = function() {
  room = {
    id: null,
    name: null,
    song: {
      room_vote_percentage: function() {
        return Math.round((room.votes.us - room.votes.down + room.listeners) / (2 * room.listeners) * 100);
      },
      name: null,
      artist: null
    },
    dj: {
      name: null,
      id: null
    },
    votes: {
      up: 0,
      down: 0
    },
    snags: 0,
    listeners: 0
  };
  return {
    moderators: [],
    djs: [],
    init: function(data) {
      return null;
    }
  };
};

({
  speaker: {
    name: null,
    id: null,
    text: null,
    init: function(data) {
      speaker.name = data.name;
      speaker.id = data.userid;
      return speaker.text = data.text;
    }
  }
});

bot = newbot(AUTH, USERID);

newbot = function() {
  var Bot, auth, room, user;
  auth = arguments[0], user = arguments[1], room = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  Bot = require("../lib/ttapi/index");
  bot = (function() {
    try {
      return new Bot(auth, user, room);
    } catch (error) {
      return new Bot(auth, user);
    }
  })();
  bot.vote = 0;
  bot.snagged = bot.autodj = bot.autobop = bot.isSnarky = bot.isFriendly = bot.isGrateful = bot.djAnnounce = bot.djGoodbye = bot.likes_to_drink(false);
  bot.reset = function() {
    bot.votes = 0;
    return bot.vote_attempts = 0;
  };
  bot.upvote = function() {
    var dovote, time;
    if (bot.votes === 1) {
      return false;
    }
    time = wait();
    log("#### Bop on @ " + time / 1000 + " #####");
    dovote = function() {
      return bot.vote('up', function(data) {
        debug("Checking vote response: " + data);
        bot.vote_attempts += 1;
        if (data.err !== "Cannot vote on your song" && data.err !== "User has already voted up") {
          bot.votes = 0;
          log("Retrying vote");
          if (!(bot.vote_attemtps > 5)) {
            return bot.upvote;
          }
        } else {
          bot.votes = 1;
          return vote_commentary;
        }
      });
    };
    return setTimeout(dovote, time);
  };
  bot.downvote = function() {
    if (bot.votes === -1) {
      return false;
    }
    bot.vote('down');
    return bot.votes = -1;
  };
  bot.down = function() {};
  bot.have_a_drink = function() {
    if (text.match(/.j refreshing *(bud|hein|coor|coron|beer|glass of milk|cup of urine)/)) {
      if (bot.likes_to_drink) {
        if (rand() % 2 === 0) {
          setTimeout(function() {
            return bot.speak("I don't usually drink on the job... but ok, thanks " + data.name + "!", wait(1, 3));
          });
        } else {
          setTimeout(function() {
            return bot.speak("w00t! Let's get wasted!", wait(1, 3));
          });
        }
      }
      return bot.upvote;
    }
  };
  bot.doautodj = function() {
    var im_a_dj, threshold;
    if (bot.autodj === false) {
      return;
    }
    im_a_dj = (room.metadata.djs.indexOf(bot.userId) !== -1 ? true : false);
    threshold = data.room.metadata.max_djs - 1;
    if (im_a_dj) {
      if (data.room.metadata.djcount > threshold) {
        if (data.room.metadata.current_dj === bot.userId) {
          bot.speak("Turtles after this song!");
          return bot.on("endsong", djDown);
        } else {
          console.log("####  Too many djs.  Getting down. ####");
          bot.speak("Who likes turtles?");
          return setTimeout(djDown, wait());
        }
      }
    } else if (data.room.metadata.djcount < threshold) {
      console.log("#####  I'm getting up: " + data.room.metadata.djcount + " < " + threshold + "  ####");
      setTimeout(bot.speak("Looks like there's room for me!  w00t!"), wait());
      return bot.addDj();
    } else {
      return console.log("####  Not doing anything: " + data.room.metadata.djcount + " of " + data.room.metadata.max_djs + " spots taken");
    }
  };
  bot.eat_subasnack = function() {
    if (speaker.text.match(/\.j subasnack/)) {
      if (bot.isGrateful) {
        setTimeout(function() {
          return bot.speak("Thanks for the subasnack " + data.name + "!", wait(1, 2));
        });
      }
      return bot.upvote;
    }
  };
  bot.announce_stats = function() {
    var current_song, percent;
    current_song = room.song.name;
    percent = vote_percentage(room_data);
    console.log("\n#### Speaking song stats ####");
    return bot.speak(current_song.metadata.artist + "  ::  " + current_song.metadata.song + " Received  -  Ups: " + room_data.upvotes + "  |  Downs: " + room_data.downvotes + "  -  That's a " + Math.round(percent) + "% room rating");
  };
  bot.snag_song = function() {
    if (percent >= snag) {
      if (snag !== false) {
        bot.playlistAll(function(data) {});
        bot.playlistAdd(current_song._id, data.list.length);
        return debulog("\n#### Added song ####\n " + current_song.metadata.artist + " // " + current_song.metadata.song + " :: " + Math.round(percent) + "\n");
      }
    }
  };
  bot.do_dj_announce = function() {
    var announce;
    if (!announce) {
      announce = "Hi " + data.user[0].name + ".  Enjoy your time on stage.  Respect the other djs!";
    }
    return setTimeout((function() {
      return bot.speak(announce);
    }), wait(1, 4));
  };
  bot.log_song_info = function() {
    console.log("\n#### Logging song stats ####");
    return console.log(current_song.metadata.artist + "  ::  " + current_song.metadata.song + " -  Ups: " + room_data.upvotes + "  |  Downs: " + room_data.downvotes + "  -  " + Math.round(percent) + "% room rating");
  };
  return bot;
};

log = function(msg) {
  if (config.log) {
    return console.log(msg);
  }
};

debug = function(msg) {
  if (config.debug) {
    return console.log(msg);
  }
};

vote_commentary = function() {
  if (!bot.isSnarky) {
    return false;
  }
  switch (time / 1000) {
    case 1:
      return bot.speak("This song is awesome!");
    case 2:
      return bot.speak("Turtle bacon anyone?");
    case 3:
      return bot.speak("Dancing is fun");
    case 4:
      return bot.speak("Oooooh is this the Pearls Jams?");
    case 5:
      return bot.speak("b0rT!!??");
    case 6:
      return bot.speak("When can I play some music?");
    case 7:
      return bot.speak(":fire:");
    case 8:
      return bot.speak("/q please?");
    case 9:
      return bot.speak("I like turtles!");
  }
};

rand = function(min, max) {
  if (!min) {
    min = 1;
  }
  if (!max) {
    max = 6;
  }
  return Math.floor(Math.random() * (max - min + 1) + min);
};

wait = function(min, max) {
  if (!min) {
    min = 1;
  }
  if (!max) {
    max = 6;
  }
  return rand(min, max) * 1000;
};

bot.on('roomChanged', function(data) {
  bot.init(data);
  room.init(data);
  return speaker.init(data);
});

bot.on('speak', function() {
  if (text.match(/sub.* bot/i)) {
    setTimeout((function() {
      return bot.speak("Hells no!!");
    }), wait());
  }
  if (text.match(/\.j botsnack/)) {
    if (isGrateful) {
      if (rand() % 4 === 0) {
        setTimeout((function() {
          return bot.speak("Can I have a subasnack too please?");
        }), 1000);
      }
    }
  }
  if (text.match(/.j subawater/)) {
    if (isGrateful) {
      if (rand() % 2 === 0) {
        setTimeout((function() {
          return bot.speak("I appreciate the gesture, but don't you have something a little stronger?");
        }), wait(1, 3));
      } else {
        setTimeout((function() {
          return bot.speak("Thanks " + data.name + ".  All those subasnacks were making me thirsty.");
        }), wait(1, 3));
      }
    }
    return upvote(false);
  }
});

bot.on('speak', bot.eat_subasnack);

bot.on('speak', bot.bot.on('speak', function() {
  if (bot.logging_enabled) {
    return console.log(speaker.text);
  }
}));

bot.on("add_dj", doautodj);

bot.on("rem_dj", doautodj);

bot.on("endsong", doautodj);

bot.on("add_dj", function(data) {});

bot.on("rem_dj", function(data) {
  var bye;
  if (djgoodbye !== "off") {
    bye = djgoodbye;
    if (!bye) {
      bye = "Thanks for playing " + data.user[0].name + " :)";
    }
    return setTimeout((function() {
      return bot.speak(bye);
    }), wait(1, 4));
  }
});

bot.on("endsong", function(data) {
  return bot.announce_stats;
});

bot.on('newsong', function() {
  return bot.do_auto_vote;
});

bot.on("newsong", function() {
  return bot.removeListener("endsong", djDown);
});

bot.on("pmmed", function(data) {
  var arg, autobop, autodj, bopcount, command, djannounce, djgoodbye, extra_args, id, isChatty, isFriendly, isGrateful, isSnide, match, message, senderid, snag, text, _results;
  text = data.text;
  console.log("#### Received PM: ####\n" + text);
  senderid = data.senderid;
  if (senderid === VDubsId) {
    command = false;
    arg = false;
    extra_args = false;
    match = text.match(/^\.(\S+) *(.*)/);
    if (match) {
      command = match[1];
      arg = match[2];
      if (command !== "speak" && match[2]) {
        match = arg.match(/^(\S+) *(.*)/);
        arg = match[1];
        extra_args = match[2];
      }
    }
    if (command) {
      switch (command) {
        case "snag":
          return bot.snag();
        case "speak":
          return bot.speak(arg);
        case "auto":
          return doautodj();
        case "up":
          bot.addDj();
          return bot.speak("WooHoo!");
        case "down":
          djDown();
          return bot.speak(":poop: :fire:");
        case "dance":
          bopcount = 0;
          return upvote(false);
        case "lame":
          return bot.vote("down");
        case "skip":
          bot.skip();
          return bot.pm("Skipping song", senderid);
        case "dequeue":
          bot.playlistRemove(0);
          return bot.pm("Removing song from queue", senderid);
        case "set":
          switch (arg) {
            case "avatar":
              bot.setAvatar(extra_args);
              return bot.pm("Set avatar to: " + extra_args, senderid);
            case "friendly":
              isFriendly = !isFriendly;
              bot.pm("Friendly set to: " + isFriendly, senderid);
              return console.log("Friendly set to: " + isFriendly);
            case "chatty":
              isChatty = !isChatty;
              bot.pm("Chatty set to: " + isChatty, senderid);
              return console.log("Chatty set to: " + isChatty);
            case "grateful":
              isGrateful = !isGrateful;
              bot.pm("Grateful set to: " + isGrateful, senderid);
              return console.log("Grateful set to: " + isGrateful);
            case "snide":
              isSnide = !isSnide;
              bot.pm("Snide set to: " + isSnide, senderid);
              return console.log("Snide set to: " + isSnide);
            case "autodj":
              autodj = !autodj;
              autobop = autodj;
              bot.pm("Autodj set to: " + autodj, senderid);
              bot.pm("Autobop set to: " + autobop, senderid);
              console.log("Autodj set to: " + autodj);
              doautodj();
              return doAutoBop(autobop);
            case "djannounce":
              djannounce = extra_args;
              message = "Changing DJ Announce to: " + djannounce;
              bot.pm(message, senderid);
              return console.log(message);
            case "djgoodbye":
              djgoodbye = extra_args;
              message = "Changing DJ Goodbye to: " + djannounce;
              bot.pm(message, senderid);
              return console.log(message);
            case "snag":
              snag = extra_args;
              message = "Changing snag threshold to: " + snag;
              bot.pm(message, senderid);
              return console.log(message);
            case "snag":
              snag = extra_args;
              message = "Changing snag threshold to: " + snag;
              bot.pm(message, senderid);
              return console.log(message);
            case "room":
              room = extra_args;
              if (room.length === 24) {
                id = room;
              } else {
                id = config.rooms[room];
              }
              if (!id) {
                bot.pm("I dont know about room " + room, senderid);
                break;
              }
              message = "Moving over to: " + room + ": " + id;
              bot.pm(message, senderid);
              console.log(message);
              return bot.roomRegister(id);
            case "autobop":
              autobop = !autobop;
              return doAutoBop(autobop);
          }
          break;
        case "show":
          switch (arg) {
            case "chatty":
              return bot.pm(isChatty, senderid);
            case "djannounce":
              return bot.pm(djannounce, senderid);
            case "djgoodbye":
              return bot.pm(djgoodbye, senderid);
            case "grateful":
              return bot.pm(isGrateful, senderid);
            case "friendly":
              return bot.pm(isFriendly, senderid);
            case "queue":
              return bot.playlistAll(function(data) {
                return console.log(data);
              });
            case "fans":
              return bot.getFans(function(data) {
                return console.log(data);
              });
            case "snag":
              return bot.pm("Snag @ " + snag, senderid);
            case "snide":
              return bot.pm("Snide @ " + isSnide, senderid);
            case "autodj":
              return bot.pm("Autodj @ " + autodj, senderid);
            case "autobop":
              return bot.pm("Autobop @ " + autobop, senderid);
            case "rooms":
              _results = [];
              for (room in config.rooms) {
                _results.push(bot.pm(room, senderid));
              }
              return _results;
          }
      }
    }
  } else {
    return bot.pm("Sorry... I'm not allowed to talk to strangers!", senderid);
  }
});

bot.on("speak", function(data) {
  return speaker.init(data);
});
